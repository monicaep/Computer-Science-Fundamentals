Exercises
1. What are some pros and cons of using linked lists instead of arrays?

Pros: A linked list doesn't have to use consecutive memory. Each node in the list
will basically just go wherever there is space for it to go. On the other hand,
arrays do need consecutive memory. This starts to become problematic especially
as arrays get larger because they have to find enough consecutive space to fit
the entire array. Adding elements to an array can also become expensive operations,
especially if the element is being added to the beginning or middle of the array,
because every element after the newly added one has to be shifted over one spot.

Cons: A con of linked lists is that elements in the list cannot be as easily
accessed as elements in an array. In an array each element has a specific index
and you can easily access that element using that index. However, in a linked
list each node is connected by having a reference to the next node in line. If
you are searching for a specific element in a linked list you must start at the
head and make your way through each node until you get to the one you were
looking for.

2. Come up with a real world example of a linked list.

A real world example of a doubly linked list is a rumor going around a high
school - assuming that each person only tells one other person. The rumor has a
starting position with one person (head) then that person tells another person
(the second node in the list) and that person tells another person (the third
node in the list), etc. Each person (node) only has access to the person who they
heard the rumor from and if they choose to share, the person who they told.

Programming Questions

1. The linked list push function should take a value, create a node, and add it
to the end of a list. Below is pseudocode for a push function for a singly linked
list. However, there is something wrong with it. Submit both an explanation of
the bug and a functional implementation of the method.

FUNCTION push(element)
CREATE node
SET node.value TO element
SET node.next TO null

IF the head node does not exist
 THEN SET head to node
ELSE
 SET current to head
 SET current.next to node
END IF
END FUNCTION

Bug: The function will make the element the head node if there is no head node. If there is already a head node the function will set the element to head.next, which would be the second node, and this is not necessarily the last node in the list.

Code:
class Node {
  constructor(element) {
    this.element = element;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.length = 0;
  }

  push(element) {
    let newNode = new Node(element);
    let currNode = this.head;
    if (this.head == null) {
      this.head = newNode;
      this.length = 1;
    } else {
      while (currNode.next != null) {
        currNode = currNode.next
      }
      currNode.next = newNode;
      this.length++;
    }
  }
}


2. Given an unsorted singly linked list, remove all duplicates from the linked
list.
Example
Input: a -> c -> d -> d -> a
Output: a -> c -> d

Plan: I will create a loop inside of a loop. The first loop will iterate through
each node and the second loop will compare each node to the node being
iterated through in the first loop. If the nodes are the same, the second node
will be removed.
Another way to do this would be to sort the list and compare each node to
the node next to it. If the nodes are the same then remove one.

Code;
class Node {
  constructor(element) {
    this.element = element;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
  }

  push(element) {
    let newNode = new Node(element);
    let currNode = this.head;
    if (this.head == null) {
      this.head = newNode;
    } else {
      while (currNode.next != null) {
        currNode = currNode.next
      }
      currNode.next = newNode;
    }
  }

  print() {
    let currNode = this.head;
    while(currNode) {
      console.log(currNode.element);
      currNode = currNode.next;
    }
  }

  remove(element) {
    let removingNode = new Node(element);
    let currNode = this.head;
    let prevNode = null;
    while (currNode) {
      if (this.head.element == removingNode.element) {
        this.head = this.head.next;
      }
      else if (currNode.element == removingNode.element) {
        prevNode.next = currNode.next;
      }
      prevNode = currNode;
      currNode = currNode.next;
    }
  }

  removeDuplicates() {
    while (this.head.element == this.head.next.element) {
      this.head = this.head.next;
    }
    let outsideCurrNode = this.head;
    let insideCurrNode = outsideCurrNode.next;
    while (insideCurrNode.next) {
      //console.log('outside: ' + outsideCurrNode.element);
      while (insideCurrNode.next) {
         if (outsideCurrNode.element == insideCurrNode.element) {
           //console.log('same');
           this.remove(outsideCurrNode.element);
         }
         //console.log('inside: ' + insideCurrNode.element);
        insideCurrNode = insideCurrNode.next;
      }
      outsideCurrNode = outsideCurrNode.next;
      insideCurrNode = outsideCurrNode.next;
    }
    if (outsideCurrNode.element == outsideCurrNode.next.element) {
      this.remove(outsideCurrNode.element);
    }
  }
}



let list = new LinkedList();
list.push(1);
list.push(1);
list.push(2);
list.push(2);
list.push(3);
list.removeDuplicates();
list.print();

let listTwo = new LinkedList();
listTwo.push(1);
listTwo.push(2);
listTwo.push(2);
listTwo.push(4);
listTwo.push(5);
listTwo.push(5);
listTwo.removeDuplicates();
listTwo.print();


3. Given an unsorted singly linked list, reverse it.
Example
Input: a -> b -> c -> d
Output: d -> c -> b -> a

Plan: Traverse through the list, keeping track of the previous, current and next nodes. While traversing I will reverse the direction the arrow is pointing.

Code:

class Node {
  constructor(element) {
    this.element = element;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head;
  }

  push(element) {
    let newNode = new Node(element);
    let currNode = this.head;
    if (this.head == null) {
      this.head = newNode;
      this.length = 1;
    } else {
      while (currNode.next != null) {
        currNode = currNode.next
      }
      currNode.next = newNode;
      this.length++;
    }
  }

  print() {
    let currNode = this.head;
    while(currNode) {
      console.log(currNode.element);
      currNode = currNode.next;
    }
  }

  reverse() {
    if (this.head == null || this.head.next == null) {
      return this.head;
    }
    let prevNode = this.head;
    let currNode = prevNode.next;
    while (currNode) {
        let temp = currNode.next;
        currNode.next = prevNode;
        prevNode = currNode;
        currNode = temp;
    }
    this.head.next = null;
    this.head = prevNode;
  }
}

let list = new LinkedList;
list.push(1);
list.push(2);
list.push(3);
list.push(4);
list.print();
list.reverse();
list.print();

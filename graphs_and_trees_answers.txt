1. What is a binary tree and what makes it unique to other trees?
A binary tree is a tree where each Node can have up to two children, a right child and a left child. This makes it unique to other trees because it can only have a maximum of two children and they are always either the right or left child.

2. What is a heuristic?
A heuristic is an educated guess that an algorithm makes in order to reach a solution faster. This can lead to lower accuracy/precision in the solution, but you can reach a solution much faster than with using an alternative method of solving the problem.

3. What is another problem besides the shortest-path problem that requires the use of heuristics?
Antivirus software makes use of heuristics. The antivirus software scans for known virus/malware code/patterns and will flag something as containing a virus/malware if it detects the code/pattern taking place.

4. What is the difference between a depth-first search and a breadth-first search?
A depth-first search (DFS) searches as deep as it can go down a single branch first before coming back up and going back down again. For example if you use DFS using the right child the search will start at the root Node then travel down the right most branch, always choosing the right child as the next Node until there is not a right child to go to. At that point it will go back up one level and choose the left child and continue right again.
A breadth-first search (BFS) searches Nodes by row. It will also start at the root node. Then it will move to the second row of Nodes and search those and so on.

5. Explain in your own words what an undirected, a-cyclic, unweighted graph is.
An undirected graph is a graph that does not have a set direction. An a-cyclic graph is one that does not form loops. An unweighted graph is one where the connection from one node to another is not weighted.

6. What kind of graph is a binary search tree?
Undirected, a-cyclic, unweighted
A binary search tree is undirected because a node can have a connection to both its parent and its children. That Node's parent also has a connection to that Node and its children have a connection to it too, so the connections are two-way connections. A binary tree is a-cyclic because the Node connections don't form loops. A binary tree is unweighted because there is no weight assigned to the connection between Nodes.

Programming Questions
1. Given a Binary Search Tree and a value, write a function that checks to see whether the value exists within the tree.

Example: The value 10 exists in the tree. The value 23 does not exist in the tree.

Plan:
To solve this problem I will write a function that takes a value as input and checks to see if the current nodes value is equal to the desire value. If they are not equal then the search will move left if the search value is less than the current node and it will move right if the search value is more than the current node value.

Code:

class Node {
  constructor(value) {
    this.value = value;
    this.right = null;
    this.left = null;
  }
}

class BinaryTree {
  constructor() {
    this.root = null;
  }

  add(value) {
    let node = new Node(value);
    let currNode = this.root;
    if (!currNode) {
      this.root = node;
      return this.root;
    }
    else {
      while(currNode) {
        if (value < currNode.value) {
          if(!currNode.left) {
            currNode.left = node;
            break;
          }
          else {
            currNode = currNode.left
          }
        }
        else {
          if(!currNode.right) {
            currNode.right = node;
            break;
          }
          else {
            currNode = currNode.right;
          }
        }
      }
    }
  }

  find(value) {
    let currNode = this.root;
    while (currNode) {
      if (currNode.value == value) {
        return true;
      }
      else if (value < currNode.value) {
        currNode = currNode.left;
      }
      else {
        currNode = currNode.right;
      }
    }
    return false;
  }
}

let tree = new BinaryTree();
tree.add(8);
tree.add(3);
tree.add(10);
tree.add(1);
tree.add(6);
tree.add(14);
tree.add(4);
tree.add(7);
tree.add(13);

console.log(tree.find(3));
console.log(tree.find(23));

2. Given a Binary Search Tree and two nodes, n1 and n2, write a function that finds the distance between the two nodes.

Example: The distance between the nodes 4 and 10 is 4. The distance between the nodes 8 and 10 is 1. The distance between the nodes 1 and 14 is 4.

Plan: I will use this equation: Dist(n1, n2) = Dist(root, n1) + Dist(root, n2) - 2*Dist(root, lca). To get the right input for this equation I will write a function that calculates the distance from the root node to a given node. And I will need another function that finds the lowest common ancestor between two nodes.

Code:

class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinaryTree {
  constructor() {
    this.root = null;
  }

  add(value) {
    let node = new Node(value);
    if (!this.root) {
      this.root = node;
      return this.root;
    }
    let currNode = this.root;
    while (currNode) {
      if(value < currNode.value) {
        if(!currNode.left) {
          currNode.left = node;
          break;
        }
        else {
          currNode = currNode.left;
        }
      }
      else {
        if(!currNode.right) {
          currNode.right = node;
          break;
        }
        else {
          currNode = currNode.right;
        }
      }
    }
  }

  distanceFromRoot(value) {
    if (this.root.value == value) {
      return 0;
    }
    let currNode = this.root;
    let count = 0;
    while(currNode) {
      if (value < currNode.value) {
        if(currNode.left.value == value) {
          count++;
          break;
        }
        else {
          currNode = currNode.left;
          count++
        }
      }
      else {
        if (currNode.right.value == value) {
          count++;
          break;
        }
        else {
          currNode = currNode.right;
          count++;
        }
      }
    }
    return count;
  }

  findLCA(root, n1, n2) {
    while (root) {
      if (n1 < root.value && n2 < root.value) {
        root = root.left;
      }
      else if (n1 > root.value && n2 > root.value) {
        root = root.right;
      }
      else {
        return root.value;
      }
    }
  }

  distanceBetweenNodes(n1, n2) {
    let distN1 = this.distanceFromRoot(n1);
    let distN2 = this.distanceFromRoot(n2);
    let LCA = this.findLCA(this.root, n1, n2);
    let distLCA = this.distanceFromRoot(LCA);
    return distN1 + distN2 - 2*distLCA;
  }
}

let tree = new BinaryTree();
tree.add(8);
tree.add(3);
tree.add(10);
tree.add(1);
tree.add(6);
tree.add(14);
tree.add(4);
tree.add(7);
tree.add(13);

console.log(tree.distanceBetweenNodes(4, 10));
console.log(tree.distanceBetweenNodes(8, 10));
console.log(tree.distanceBetweenNodes(1, 14));
